<DocPage toc={[
  { title: "Architecture", url: "#architecture", depth: 2 },
  { title: "The Scan Limit Problem", url: "#the-scan-limit-problem", depth: 3 },
  { title: "Discrete Time Buckets", url: "#discrete-time-buckets", depth: 3 },
  { title: "Resources", url: "#resources", depth: 2 },
  { title: "Schedules", url: "#schedules", depth: 2 },
  { title: "Event Types", url: "#event-types", depth: 2 },
  { title: "Presence System", url: "#presence-system", depth: 2 },
  { title: "How Presence Works", url: "#how-presence-works", depth: 3 },
  { title: "Multi-Slot Batching", url: "#multi-slot-batching", depth: 3 },
  { title: "Data Flow", url: "#data-flow", depth: 2 },
  { title: "Authentication & Authorization", url: "#authentication--authorization", depth: 2 },
  { title: "Trust Zones Overview", url: "#trust-zones-overview", depth: 3 },
  { title: "Why Split APIs", url: "#why-split-apis", depth: 3 },
  { title: "Gateway Pattern", url: "#gateway-pattern", depth: 3 },
  { title: "Frontend vs Backend Auth", url: "#frontend-vs-backend-auth", depth: 3 },
]}>

# Core Concepts

Understanding the architecture and data model behind ConvexBooking.

## Architecture

ConvexBooking uses a **discrete time bucket** pattern that enables O(1) availability queries regardless of how many historical bookings exist. This is fundamentally different from traditional booking systems.

### The Scan Limit Problem

Traditional booking systems use range queries to check availability:

```sql
SELECT * FROM bookings
WHERE start < end_date AND end > start_date
```

**The problem with Convex:** With 50,000 past bookings, this would scan ALL documents just to find the 3 currently active ones. Convex has a 16k document scan limit per query â€” this approach would crash.

### Discrete Time Buckets

Instead of querying bookings directly, we **pre-compute and store** availability in discrete 15-minute buckets:

```typescript
// Daily availability document
{
  resourceId: "studio-a",
  date: "2025-01-15",
  busySlots: [32, 33, 34, 35]  // Occupied 15-min slot indices (0-95)
}
```

**The 96-Slot System:**
- Each day has 96 slots (24 hours Ã— 4 quarters)
- `00:00` â†’ Slot 0
- `14:00` â†’ Slot 56
- `23:45` â†’ Slot 95

**O(1) Availability Check:**
1. Fetch ONE document for the date
2. Check if required slots are in `busySlots` array
3. Cost: 1 database read. Always. Even with 10 million historical bookings.

**ACID Booking Transaction:**

When a booking is created:
1. Fetch availability documents for the date range
2. Check: Are any required slots already busy?
3. If conflict: Throw error â†’ Transaction aborts
4. If clear: Update `busySlots` + Insert booking record
5. Transaction commits atomically

## Resources

A **Resource** is anything that can be booked â€” a room, a piece of equipment, a person, etc.

```typescript
// Creating a resource
await ctx.runMutation(api.booking.createResource, {
  id: "studio-a",
  organizationId: "org-1",
  name: "Studio A",
  type: "room",
  timezone: "Europe/Berlin",
});
```

**Key fields:**
- `id` - Unique identifier (you control this)
- `name` - Display name
- `type` - Category for filtering (`room`, `equipment`, `person`)
- `timezone` - Resource's local timezone for schedule calculations
- `isActive` - Soft delete flag

Resources can also be **add-ons** that are bundled with a primary resource.

## Schedules

A **Schedule** defines when a resource is available for booking.

```typescript
await ctx.runMutation(api.booking.createSchedule, {
  id: "business-hours",
  organizationId: "org-1",
  name: "Business Hours",
  timezone: "Europe/Berlin",
  isDefault: true,
  weeklyHours: [
    { dayOfWeek: 1, startTime: "09:00", endTime: "17:00" }, // Monday
    { dayOfWeek: 2, startTime: "09:00", endTime: "17:00" }, // Tuesday
    { dayOfWeek: 3, startTime: "09:00", endTime: "17:00" }, // Wednesday
    { dayOfWeek: 4, startTime: "09:00", endTime: "17:00" }, // Thursday
    { dayOfWeek: 5, startTime: "09:00", endTime: "17:00" }, // Friday
  ],
});
```

Schedules support:
- **Weekly hours** - Regular availability per day of week
- **Date overrides** - Special hours for specific dates
- **Default schedule** - Fallback when a resource doesn't have a specific schedule

## Event Types

An **Event Type** is a booking template that connects resources and schedules with booking rules.

```typescript
await ctx.runMutation(api.booking.createEventType, {
  id: "studio-session",
  slug: "studio-session",
  title: "Studio Session",
  lengthInMinutes: 60,
  lengthInMinutesOptions: [60, 120, 300], // 1h, 2h, or 5h options
  slotInterval: 60, // Start times every hour
  timezone: "Europe/Berlin",
  organizationId: "org-1",
  scheduleId: "business-hours",
});
```

**Key fields:**
- `lengthInMinutes` - Default duration
- `lengthInMinutesOptions` - Available duration choices
- `slotInterval` - How often slots appear (e.g., every 30min, every hour)
- `bufferBefore` / `bufferAfter` - Gap between bookings

Event types are linked to resources via a many-to-many relationship. One event type can be booked on multiple resources.

## Presence System

The **Presence System** provides real-time slot locking to prevent double bookings while users are selecting time slots.

### How Presence Works

```
User selects slot â†’ Immediate hold (heartbeat every 5s)
â”œâ”€ Frontend: useSlotHold hook sends heartbeat
â”œâ”€ Backend: presence.heartbeat mutation records hold
â”œâ”€ Cleanup: Scheduled job removes stale holds after 10s
â””â”€ Release: Explicit on navigation OR timeout
```

When User A is viewing a time slot:
1. Their browser sends a heartbeat every 5 seconds
2. Other users (User B) see that slot marked as "Reserved"
3. If User A navigates away or their browser closes, the hold expires after 10 seconds
4. User B then sees the slot become available again

### Multi-Slot Batching

For longer bookings (e.g., 5 hours), multiple slot intervals need to be held:

```typescript
// 5h booking starting at 10:00 with 60min slot intervals
// Holds: 10:00, 11:00, 12:00, 13:00, 14:00
heartbeat({
  resourceId: "studio-a",
  slots: ["10:00", "11:00", "12:00", "13:00", "14:00"],
  user: sessionId
});
```

This is handled automatically by the `useSlotHold` hook.

## Data Flow

Here's how data flows through the system:

```
1. User opens booking page
   â†“
2. getMonthAvailability() â†’ Calendar dots (which days have slots)
   â†“
3. User selects a date
   â†“
4. getDaySlots() â†’ Available time slots for that day
   â†“
5. getDatePresence() â†’ Which slots are currently held by others
   â†“
6. Frontend merges: available slots - held slots = bookable slots
   â†“
7. User selects a slot â†’ useSlotHold starts heartbeat
   â†“
8. User submits booking form â†’ createBooking mutation
   â†“
9. Backend: Validate â†’ Update busySlots â†’ Create booking record
   â†“
10. Success! Other users see the slot disappear (real-time)
```

**Key insight:** Steps 4 and 5 are separate queries. `getDaySlots` rarely changes (only when bookings are made). `getDatePresence` changes every 5 seconds (heartbeats). Keeping them separate means the heavy slot calculation is cached while presence updates are lightweight.

## Authentication & Authorization

ConvexBooking implements a **three-zone trust model** that separates public operations, authenticated user actions, and administrative functions.

### Trust Zones Overview

The system divides operations into three security zones:

**ðŸŸ¢ Green Zone (Public - No Authentication Required):**
- Browsing available resources
- Checking availability (month/day slots)
- Viewing event types
- Holding time slots (presence system uses session-based auth)

**ðŸŸ¡ Yellow Zone (Authenticated - Sign-in Required):**
- Creating bookings
- Viewing own bookings
- Cancelling bookings
- Any operation that involves user identity

**ðŸ”´ Red Zone (Admin - Admin Role Required):**
- Creating/editing resources
- Managing event types
- Configuring schedules
- Viewing all bookings
- System configuration

### Why Split APIs

A single API endpoint cannot enforce different authentication rules for different operations. By separating functionality into distinct files, we make security boundaries explicit:

```typescript
// public.ts - Green Zone (no auth)
export const listResources = publicQuery({
  args: { organizationId: v.string() },
  handler: async (ctx, args) => {
    // No ctx.auth check needed
    return await ctx.runQuery(internal.resources.listResources, args);
  }
});

// admin.ts - Red Zone (admin required)
export const createResource = adminMutation({
  args: { /* ... */ },
  handler: async (ctx, args) => {
    // Auth already enforced by adminMutation builder
    // Only admins can reach this code
    return await ctx.runMutation(internal.resources.createResource, args);
  }
});
```

**Benefits:**
- Frontend can show/hide UI based on user role (`useAuthFromAuthKit()`)
- Backend enforces authorization regardless of frontend state
- Security review is easier (audit `admin.ts` for sensitive operations)
- API boundaries match product features (public booking vs admin dashboard)

### Gateway Pattern

Authentication is enforced in **wrapper functions**, not inside the component itself:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      App Layer                          â”‚
â”‚                                                         â”‚
â”‚  public.ts                      admin.ts                â”‚
â”‚  â”œâ”€ publicQuery                 â”œâ”€ adminQuery           â”‚
â”‚  â”œâ”€ publicMutation              â”œâ”€ adminMutation        â”‚
â”‚  â”‚  (no auth check)             â”‚  (requires admin)     â”‚
â”‚  â”‚         â†“                    â”‚         â†“             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚            â”‚                               â”‚             â”‚
â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                        â†“                                 â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚              â”‚  Booking Component  â”‚                     â”‚
â”‚              â”‚   (Trusted Zone)    â”‚                     â”‚
â”‚              â”‚                     â”‚                     â”‚
â”‚              â”‚  Assumes valid      â”‚                     â”‚
â”‚              â”‚  input from caller  â”‚                     â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Custom function builders** handle the authentication logic:

```typescript
// convex/lib/functionBuilders.ts
export const publicQuery = customQuery(query, {
  args: {},
  input: async (ctx, args) => {
    // No authentication check - anyone can call
    return { ctx, args };
  }
});

export const adminMutation = customMutation(mutation, {
  args: {},
  input: async (ctx, args) => {
    // Extract and verify admin role
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const role = identity.role as string | undefined;
    if (role !== "admin") {
      throw new Error("Admin access required");
    }

    return { ctx: { ...ctx, userId: identity.subject }, args };
  }
});
```

**Special Case - Presence System:**

The presence system uses **session-based authentication** instead of JWT tokens:

- Users get a random `sessionId` on page load (no sign-in required)
- Heartbeats are tied to the session, not a user account
- This allows anonymous users to "reserve" slots temporarily
- Real booking creation still requires full authentication

### Frontend vs Backend Auth

**Frontend Authentication (UX Only):**
```typescript
// app/demo/layout.tsx
const { isLoading, isAuthenticated } = useAuthFromAuthKit();

if (isAuthenticated) {
  return <AdminDashboard />;  // Show admin UI
} else {
  return <SignInPrompt />;    // Redirect to login
}
```

**Backend Authentication (Security Enforcement):**
```typescript
// convex/admin.ts
export const createResource = adminMutation({
  handler: async (ctx, args) => {
    // ctx.userId is guaranteed to exist here
    // adminMutation builder already verified admin role
    // Frontend checks were just for UX
    return await ctx.runMutation(internal.resources.create, args);
  }
});
```

**Critical Rule:** Never trust frontend authentication for security decisions. Frontend checks improve UX (hide buttons users can't use), but the backend must independently verify every operation.

**Example attack scenario:**
1. User opens DevTools, finds admin API endpoint
2. User manually calls `ctx.runMutation(api.admin.deleteResource, { id: "studio-a" })`
3. Backend checks authentication â†’ No valid admin role â†’ Request rejected

Even if the frontend accidentally showed an admin button, the backend would still block unauthorized access.

For detailed information on implementing authentication, managing user roles, and integrating with WorkOS AuthKit, see [Authentication](/docs/authentication).

</DocPage>
